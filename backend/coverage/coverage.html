
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tp06-testing/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">tp06-testing/internal/database/database.go (0.0%)</option>
				
				<option value="file2">tp06-testing/internal/handlers/auth_handler.go (0.0%)</option>
				
				<option value="file3">tp06-testing/internal/handlers/post_handler.go (0.0%)</option>
				
				<option value="file4">tp06-testing/internal/repository/post_repository.go (0.0%)</option>
				
				<option value="file5">tp06-testing/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file6">tp06-testing/internal/router/router.go (0.0%)</option>
				
				<option value="file7">tp06-testing/internal/services/auth_service.go (90.3%)</option>
				
				<option value="file8">tp06-testing/internal/services/post_service.go (40.0%)</option>
				
				<option value="file9">tp06-testing/tests/mocks/post_repository_mock.go (50.0%)</option>
				
				<option value="file10">tp06-testing/tests/mocks/user_repository_mock.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"

        "tp06-testing/internal/database"
        "tp06-testing/internal/handlers"
        "tp06-testing/internal/repository"
        "tp06-testing/internal/router"
        "tp06-testing/internal/services"
)

func main() <span class="cov0" title="0">{
        // Inicializar base de datos
        db, err := database.InitDB("./database.db")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error al inicializar la base de datos:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Crear repositorios
        userRepo := repository.NewSQLiteUserRepository(db)
        postRepo := repository.NewSQLitePostRepository(db)

        // Crear servicios
        authService := services.NewAuthService(userRepo)
        postService := services.NewPostService(postRepo, userRepo)

        // Crear handlers
        authHandler := handlers.NewAuthHandler(authService)
        postHandler := handlers.NewPostHandler(postService)

        // Configurar rutas
        r := router.Setup(authHandler, postHandler)

        // Iniciar servidor
        log.Println("🚀 Servidor corriendo en http://localhost:8080")
        if err := http.ListenAndServe(":8080", r); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error al iniciar el servidor:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "database/sql"
        "log"

        _ "github.com/mattn/go-sqlite3"
)

// InitDB inicializa la base de datos SQLite
func InitDB(filepath string) (*sql.DB, error) <span class="cov0" title="0">{
        // Abrir conexión a SQLite
        db, err := sql.Open("sqlite3", filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Verificar que la conexión funcione
        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Crear las tablas
        <span class="cov0" title="0">if err = createTables(db); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Base de datos inicializada correctamente")
        return db, nil</span>
}

// createTables crea el schema de la base de datos
func createTables(db *sql.DB) error <span class="cov0" title="0">{
        schema := `
        -- Tabla de usuarios
        CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email TEXT UNIQUE NOT NULL,
                password TEXT NOT NULL,
                username TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Tabla de posts
        CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                user_id INTEGER NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );

        -- Tabla de comentarios
        CREATE TABLE IF NOT EXISTS comments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                post_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );

        -- Índices para mejorar rendimiento
        CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
        CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id);
        CREATE INDEX IF NOT EXISTS idx_comments_user_id ON comments(user_id);
        `

        _, err := db.Exec(schema)
        return err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "tp06-testing/internal/models"
        "tp06-testing/internal/services"
)

// AuthHandler maneja las peticiones HTTP de autenticación
type AuthHandler struct {
        authService *services.AuthService
}

// NewAuthHandler crea una nueva instancia
func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

// Register maneja POST /api/auth/register
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Decodificar el body JSON
        var req models.RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "JSON inválido")
                return
        }</span>

        // Llamar al servicio
        <span class="cov0" title="0">user, err := h.authService.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Responder con el usuario creado
        <span class="cov0" title="0">respondWithJSON(w, http.StatusCreated, user)</span>
}

// Login maneja POST /api/auth/login
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Decodificar el body JSON
        var creds models.Credentials
        if err := json.NewDecoder(r.Body).Decode(&amp;creds); err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "JSON inválido")
                return
        }</span>

        // Llamar al servicio
        <span class="cov0" title="0">user, err := h.authService.Login(&amp;creds)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusUnauthorized, err.Error())
                return
        }</span>

        // Responder con el usuario autenticado
        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, user)</span>
}

// Funciones auxiliares para responder JSON

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) <span class="cov0" title="0">{
        response, _ := json.Marshal(payload)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        w.Write(response)
}</span>

func respondWithError(w http.ResponseWriter, code int, message string) <span class="cov0" title="0">{
        respondWithJSON(w, code, map[string]string{"error": message})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "tp06-testing/internal/models"
        "tp06-testing/internal/services"
)

// PostHandler maneja las peticiones HTTP de posts
type PostHandler struct {
        postService *services.PostService
}

// NewPostHandler crea una nueva instancia
func NewPostHandler(postService *services.PostService) *PostHandler <span class="cov0" title="0">{
        return &amp;PostHandler{
                postService: postService,
        }
}</span>

// CreatePost maneja POST /api/posts
func (h *PostHandler) CreatePost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Decodificar el body
        var req models.CreatePostRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "JSON inválido")
                return
        }</span>

        // Por simplicidad, el userID viene en el header
        // En producción usarías JWT o sesiones
        <span class="cov0" title="0">userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusUnauthorized, "Usuario no autenticado")
                return
        }</span>

        <span class="cov0" title="0">userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "User ID inválido")
                return
        }</span>

        // Llamar al servicio
        <span class="cov0" title="0">post, err := h.postService.CreatePost(&amp;req, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusCreated, post)</span>
}

// GetAllPosts maneja GET /api/posts
func (h *PostHandler) GetAllPosts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        posts, err := h.postService.GetAllPosts()
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, posts)</span>
}

// GetPostByID maneja GET /api/posts/{id}
func (h *PostHandler) GetPostByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Obtener el ID de la URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "ID inválido")
                return
        }</span>

        <span class="cov0" title="0">post, err := h.postService.GetPostByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusNotFound, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, post)</span>
}

// DeletePost maneja DELETE /api/posts/{id}
func (h *PostHandler) DeletePost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Obtener el ID de la URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "ID inválido")
                return
        }</span>

        // Obtener userID del header
        <span class="cov0" title="0">userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusUnauthorized, "Usuario no autenticado")
                return
        }</span>

        <span class="cov0" title="0">userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "User ID inválido")
                return
        }</span>

        // Llamar al servicio
        <span class="cov0" title="0">err = h.postService.DeletePost(id, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusForbidden, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, map[string]string{"message": "Post eliminado"})</span>
}

// CreateComment maneja POST /api/posts/{id}/comments
func (h *PostHandler) CreateComment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Obtener postID de la URL
        vars := mux.Vars(r)
        postID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "ID inválido")
                return
        }</span>

        // Decodificar el body
        <span class="cov0" title="0">var req models.CreateCommentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "JSON inválido")
                return
        }</span>

        // Obtener userID del header
        <span class="cov0" title="0">userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusUnauthorized, "Usuario no autenticado")
                return
        }</span>

        <span class="cov0" title="0">userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "User ID inválido")
                return
        }</span>

        // Llamar al servicio
        <span class="cov0" title="0">comment, err := h.postService.CreateComment(postID, &amp;req, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusCreated, comment)</span>
}

// GetComments maneja GET /api/posts/{id}/comments
func (h *PostHandler) GetComments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Obtener postID de la URL
        vars := mux.Vars(r)
        postID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "ID inválido")
                return
        }</span>

        <span class="cov0" title="0">comments, err := h.postService.GetCommentsByPostID(postID)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusNotFound, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, comments)</span>
}

// DeleteComment handles DELETE /api/posts/{postId}/comments/{commentId}
func (h *PostHandler) DeleteComment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        postID, err := strconv.Atoi(vars["postId"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "Post ID inválido")
                return
        }</span>
        <span class="cov0" title="0">commentID, err := strconv.Atoi(vars["commentId"])
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "Comment ID inválido")
                return
        }</span>

        <span class="cov0" title="0">userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusUnauthorized, "Usuario no autenticado")
                return
        }</span>
        <span class="cov0" title="0">userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusBadRequest, "User ID inválido")
                return
        }</span>

        <span class="cov0" title="0">err = h.postService.DeleteComment(postID, commentID, userID)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusForbidden, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondWithJSON(w, http.StatusOK, map[string]string{"message": "Comentario eliminado"})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "tp06-testing/internal/models"
)

// PostRepository define las operaciones sobre posts
type PostRepository interface {
        Create(post *models.Post) error
        FindAll() ([]*models.Post, error)
        FindByID(id int) (*models.Post, error)
        Delete(id int) error
        CreateComment(comment *models.Comment) error
        FindCommentsByPostID(postID int) ([]*models.Comment, error)
        DeleteComment(postID int, commentID int, userID int) error
}

// SQLitePostRepository implementa PostRepository usando SQLite
type SQLitePostRepository struct {
        db *sql.DB
}

// NewSQLitePostRepository crea una nueva instancia
func NewSQLitePostRepository(db *sql.DB) *SQLitePostRepository <span class="cov0" title="0">{
        return &amp;SQLitePostRepository{db: db}
}</span>

// Create inserta un nuevo post
func (r *SQLitePostRepository) Create(post *models.Post) error <span class="cov0" title="0">{
        query := `
                INSERT INTO posts (title, content, user_id, created_at)
                VALUES (?, ?, ?, datetime('now'))
        `
        result, err := r.db.Exec(query, post.Title, post.Content, post.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">post.ID = int(id)
        return nil</span>
}

// FindAll obtiene todos los posts con información del autor
func (r *SQLitePostRepository) FindAll() ([]*models.Post, error) <span class="cov0" title="0">{
        query := `
                SELECT p.id, p.title, p.content, p.user_id, u.username, p.created_at
                FROM posts p
                JOIN users u ON p.user_id = u.id
                ORDER BY p.created_at DESC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var posts []*models.Post
        for rows.Next() </span><span class="cov0" title="0">{
                post := &amp;models.Post{}
                err := rows.Scan(
                        &amp;post.ID,
                        &amp;post.Title,
                        &amp;post.Content,
                        &amp;post.UserID,
                        &amp;post.Username,
                        &amp;post.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">posts = append(posts, post)</span>
        }

        <span class="cov0" title="0">return posts, nil</span>
}

// FindByID busca un post por ID
func (r *SQLitePostRepository) FindByID(id int) (*models.Post, error) <span class="cov0" title="0">{
        query := `
                SELECT p.id, p.title, p.content, p.user_id, u.username, p.created_at
                FROM posts p
                JOIN users u ON p.user_id = u.id
                WHERE p.id = ?
        `

        post := &amp;models.Post{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;post.ID,
                &amp;post.Title,
                &amp;post.Content,
                &amp;post.UserID,
                &amp;post.Username,
                &amp;post.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return post, nil</span>
}

// Delete elimina un post por ID
func (r *SQLitePostRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM posts WHERE id = ?`
        _, err := r.db.Exec(query, id)
        return err
}</span>

// CreateComment inserta un nuevo comentario
func (r *SQLitePostRepository) CreateComment(comment *models.Comment) error <span class="cov0" title="0">{
        query := `
                INSERT INTO comments (post_id, user_id, content, created_at)
                VALUES (?, ?, ?, datetime('now'))
        `
        result, err := r.db.Exec(query, comment.PostID, comment.UserID, comment.Content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">comment.ID = int(id)
        return nil</span>
}

// FindCommentsByPostID obtiene todos los comentarios de un post
func (r *SQLitePostRepository) FindCommentsByPostID(postID int) ([]*models.Comment, error) <span class="cov0" title="0">{
        query := `
                SELECT c.id, c.post_id, c.user_id, u.username, c.content, c.created_at
                FROM comments c
                JOIN users u ON c.user_id = u.id
                WHERE c.post_id = ?
                ORDER BY c.created_at ASC
        `

        rows, err := r.db.Query(query, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var comments []*models.Comment
        for rows.Next() </span><span class="cov0" title="0">{
                comment := &amp;models.Comment{}
                err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.PostID,
                        &amp;comment.UserID,
                        &amp;comment.Username,
                        &amp;comment.Content,
                        &amp;comment.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">comments = append(comments, comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

func (r *SQLitePostRepository) DeleteComment(postID int, commentID int, userID int) error <span class="cov0" title="0">{
        query := `
                DELETE FROM comments
                WHERE id = ? AND post_id = ? AND user_id = ?
        `
        result, err := r.db.Exec(query, commentID, postID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("no tienes permiso para eliminar este comentario o no existe")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "database/sql"

        "tp06-testing/internal/models"
)

// UserRepository define las operaciones sobre usuarios
// INTERFACE: permite crear mocks fácilmente para testing
type UserRepository interface {
        Create(user *models.User) error
        FindByEmail(email string) (*models.User, error)
        FindByID(id int) (*models.User, error)
}

// SQLiteUserRepository implementa UserRepository usando SQLite
type SQLiteUserRepository struct {
        db *sql.DB
}

// NewSQLiteUserRepository crea una nueva instancia
func NewSQLiteUserRepository(db *sql.DB) *SQLiteUserRepository <span class="cov0" title="0">{
        return &amp;SQLiteUserRepository{db: db}
}</span>

// Create inserta un nuevo usuario en la base de datos
func (r *SQLiteUserRepository) Create(user *models.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (email, password, username, created_at)
                VALUES (?, ?, ?, datetime('now'))
        `
        result, err := r.db.Exec(query, user.Email, user.Password, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.ID = int(id)
        return nil</span>
}

// FindByEmail busca un usuario por email
func (r *SQLiteUserRepository) FindByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        query := `SELECT id, email, password, username, created_at FROM users WHERE email = ?`

        user := &amp;models.User{}
        err := r.db.QueryRow(query, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Username,
                &amp;user.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil // Usuario no encontrado (no es error)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// FindByID busca un usuario por ID
func (r *SQLiteUserRepository) FindByID(id int) (*models.User, error) <span class="cov0" title="0">{
        query := `SELECT id, email, password, username, created_at FROM users WHERE id = ?`

        user := &amp;models.User{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Username,
                &amp;user.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package router

import (
        "net/http"

        "tp06-testing/internal/handlers"

        "github.com/gorilla/mux"
)

// Setup configura todas las rutas de la aplicación
func Setup(authHandler *handlers.AuthHandler, postHandler *handlers.PostHandler) *mux.Router <span class="cov0" title="0">{
        router := mux.NewRouter()

        // Middleware CORS
        router.Use(corsMiddleware)

        // Rutas de autenticación
        router.HandleFunc("/api/auth/register", authHandler.Register).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/auth/login", authHandler.Login).Methods("POST", "OPTIONS")

        // Rutas de posts
        router.HandleFunc("/api/posts", postHandler.GetAllPosts).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/posts", postHandler.CreatePost).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/posts/{id}", postHandler.GetPostByID).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/posts/{id}", postHandler.DeletePost).Methods("DELETE", "OPTIONS")

        // Rutas de comentarios
        router.HandleFunc("/api/posts/{id}/comments", postHandler.GetComments).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/posts/{id}/comments", postHandler.CreateComment).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/posts/{postId}/comments/{commentId}", postHandler.DeleteComment).Methods("DELETE", "OPTIONS")

        return router
}</span>

// corsMiddleware permite peticiones desde el frontend
func corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Configurar headers CORS
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-User-ID")

                // Si es una petición OPTIONS (preflight), responder inmediatamente
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "errors"
        "strings"

        "tp06-testing/internal/models"
        "tp06-testing/internal/repository"
)

// AuthService maneja la lógica de autenticación
type AuthService struct {
        userRepo repository.UserRepository
}

// NewAuthService crea una nueva instancia
func NewAuthService(userRepo repository.UserRepository) *AuthService <span class="cov10" title="11">{
        return &amp;AuthService{
                userRepo: userRepo,
        }
}</span>

// Register registra un nuevo usuario
// Aquí validamos las reglas de negocio
func (s *AuthService) Register(req *models.RegisterRequest) (*models.User, error) <span class="cov7" title="6">{
        // Validación 1: Email no puede estar vacío
        if strings.TrimSpace(req.Email) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("el email es requerido")
        }</span>

        // Validación 2: Email debe contener @
        <span class="cov7" title="5">if !strings.Contains(req.Email, "@") </span><span class="cov1" title="1">{
                return nil, errors.New("el email debe ser válido")
        }</span>

        // Validación 3: Password debe tener al menos 6 caracteres
        <span class="cov6" title="4">if len(req.Password) &lt; 6 </span><span class="cov1" title="1">{
                return nil, errors.New("la contraseña debe tener al menos 6 caracteres")
        }</span>

        // Validación 4: Username no puede estar vacío
        <span class="cov5" title="3">if strings.TrimSpace(req.Username) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("el nombre de usuario es requerido")
        }</span>

        // Validación 5: Verificar que el email no esté registrado
        <span class="cov3" title="2">existingUser, err := s.userRepo.FindByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                return nil, errors.New("el email ya está registrado")
        }</span>

        // Crear el usuario
        <span class="cov1" title="1">user := &amp;models.User{
                Email:    strings.ToLower(strings.TrimSpace(req.Email)),
                Password: req.Password, // En producción: hashear con bcrypt
                Username: strings.TrimSpace(req.Username),
        }

        err = s.userRepo.Create(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

// Login autentica un usuario
func (s *AuthService) Login(creds *models.Credentials) (*models.User, error) <span class="cov7" title="5">{
        // Validación 1: Email no puede estar vacío
        if strings.TrimSpace(creds.Email) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("el email es requerido")
        }</span>

        // Validación 2: Password no puede estar vacío
        <span class="cov6" title="4">if creds.Password == "" </span><span class="cov1" title="1">{
                return nil, errors.New("la contraseña es requerida")
        }</span>

        // Buscar usuario por email
        <span class="cov5" title="3">user, err := s.userRepo.FindByEmail(strings.ToLower(strings.TrimSpace(creds.Email)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validación 3: Usuario debe existir
        <span class="cov5" title="3">if user == nil </span><span class="cov1" title="1">{
                return nil, errors.New("credenciales inválidas")
        }</span>

        // Validación 4: Password debe coincidir
        // En producción: usar bcrypt.CompareHashAndPassword
        <span class="cov3" title="2">if user.Password != creds.Password </span><span class="cov1" title="1">{
                return nil, errors.New("credenciales inválidas")
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "errors"
        "strings"

        "tp06-testing/internal/models"
        "tp06-testing/internal/repository"
)

// PostService maneja la lógica de posts y comentarios
type PostService struct {
        postRepo repository.PostRepository
        userRepo repository.UserRepository
}

// NewPostService crea una nueva instancia
func NewPostService(postRepo repository.PostRepository, userRepo repository.UserRepository) *PostService <span class="cov10" title="12">{
        return &amp;PostService{
                postRepo: postRepo,
                userRepo: userRepo,
        }
}</span>

// CreatePost crea un nuevo post
func (s *PostService) CreatePost(req *models.CreatePostRequest, userID int) (*models.Post, error) <span class="cov6" title="5">{
        // Validación 1: Título no puede estar vacío
        if strings.TrimSpace(req.Title) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("el título es requerido")
        }</span>

        // Validación 2: Título debe tener al menos 3 caracteres
        <span class="cov6" title="4">if len(strings.TrimSpace(req.Title)) &lt; 3 </span><span class="cov0" title="0">{
                return nil, errors.New("el título debe tener al menos 3 caracteres")
        }</span>

        // Validación 3: Contenido no puede estar vacío
        <span class="cov6" title="4">if strings.TrimSpace(req.Content) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("el contenido es requerido")
        }</span>

        // Validación 4: Usuario debe existir
        <span class="cov4" title="3">user, err := s.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">if user == nil </span><span class="cov1" title="1">{
                return nil, errors.New("usuario no encontrado")
        }</span>

        // Crear el post
        <span class="cov3" title="2">post := &amp;models.Post{
                Title:   strings.TrimSpace(req.Title),
                Content: strings.TrimSpace(req.Content),
                UserID:  userID,
        }

        err = s.postRepo.Create(post)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Agregar el username para la respuesta
        <span class="cov1" title="1">post.Username = user.Username

        return post, nil</span>
}

// GetAllPosts obtiene todos los posts
func (s *PostService) GetAllPosts() ([]*models.Post, error) <span class="cov0" title="0">{
        posts, err := s.postRepo.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Si no hay posts, devolver lista vacía (no es error)
        <span class="cov0" title="0">if posts == nil </span><span class="cov0" title="0">{
                return []*models.Post{}, nil
        }</span>

        <span class="cov0" title="0">return posts, nil</span>
}

// GetPostByID obtiene un post específico
func (s *PostService) GetPostByID(id int) (*models.Post, error) <span class="cov0" title="0">{
        // Validación: ID debe ser positivo
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("id inválido")
        }</span>

        <span class="cov0" title="0">post, err := s.postRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if post == nil </span><span class="cov0" title="0">{
                return nil, errors.New("post no encontrado")
        }</span>

        <span class="cov0" title="0">return post, nil</span>
}

// DeletePost elimina un post (solo el autor puede hacerlo)
func (s *PostService) DeletePost(postID int, userID int) error <span class="cov4" title="3">{
        // Validación 1: Post debe existir
        post, err := s.postRepo.FindByID(postID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="3">if post == nil </span><span class="cov1" title="1">{
                return errors.New("post no encontrado")
        }</span>

        // Validación 2: Solo el autor puede eliminar
        <span class="cov3" title="2">if post.UserID != userID </span><span class="cov1" title="1">{
                return errors.New("no tienes permiso para eliminar este post")
        }</span>

        // Eliminar
        <span class="cov1" title="1">return s.postRepo.Delete(postID)</span>
}

// CreateComment agrega un comentario a un post
func (s *PostService) CreateComment(postID int, req *models.CreateCommentRequest, userID int) (*models.Comment, error) <span class="cov0" title="0">{
        // Validación 1: Contenido no puede estar vacío
        if strings.TrimSpace(req.Content) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("el contenido del comentario es requerido")
        }</span>

        // Validación 2: Post debe existir
        <span class="cov0" title="0">post, err := s.postRepo.FindByID(postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if post == nil </span><span class="cov0" title="0">{
                return nil, errors.New("post no encontrado")
        }</span>

        // Validación 3: Usuario debe existir
        <span class="cov0" title="0">user, err := s.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("usuario no encontrado")
        }</span>

        // Crear comentario
        <span class="cov0" title="0">comment := &amp;models.Comment{
                PostID:  postID,
                UserID:  userID,
                Content: strings.TrimSpace(req.Content),
        }

        err = s.postRepo.CreateComment(comment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Agregar username para la respuesta
        <span class="cov0" title="0">comment.Username = user.Username

        return comment, nil</span>
}

// GetCommentsByPostID obtiene todos los comentarios de un post
func (s *PostService) GetCommentsByPostID(postID int) ([]*models.Comment, error) <span class="cov0" title="0">{
        // Validación: Post debe existir
        post, err := s.postRepo.FindByID(postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if post == nil </span><span class="cov0" title="0">{
                return nil, errors.New("post no encontrado")
        }</span>

        <span class="cov0" title="0">comments, err := s.postRepo.FindCommentsByPostID(postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Si no hay comentarios, devolver lista vacía
        <span class="cov0" title="0">if comments == nil </span><span class="cov0" title="0">{
                return []*models.Comment{}, nil
        }</span>

        <span class="cov0" title="0">return comments, nil</span>
}

func (s *PostService) DeleteComment(postID int, commentID int, userID int) error <span class="cov6" title="4">{
        // Validación: Post debe existir
        post, err := s.postRepo.FindByID(postID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="4">if post == nil </span><span class="cov1" title="1">{
                return errors.New("post no encontrado")
        }</span>

        // Validación: Usuario debe existir
        <span class="cov4" title="3">user, err := s.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="3">if user == nil </span><span class="cov1" title="1">{
                return errors.New("usuario no encontrado")
        }</span>

        // Eliminar comentario (solo el autor puede)
        <span class="cov3" title="2">return s.postRepo.DeleteComment(postID, commentID, userID)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package mocks

import (
        "tp06-testing/internal/models"

        "github.com/stretchr/testify/mock"
)

// MockPostRepository es un mock del PostRepository
type MockPostRepository struct {
        mock.Mock
}

// Create simula la creación de un post
func (m *MockPostRepository) Create(post *models.Post) error <span class="cov4" title="2">{
        args := m.Called(post)
        return args.Error(0)
}</span>

// FindAll simula obtener todos los posts
func (m *MockPostRepository) FindAll() ([]*models.Post, error) <span class="cov0" title="0">{
        args := m.Called()

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).([]*models.Post), args.Error(1)</span>
}

// FindByID simula buscar un post por ID
func (m *MockPostRepository) FindByID(id int) (*models.Post, error) <span class="cov10" title="7">{
        args := m.Called(id)

        if args.Get(0) == nil </span><span class="cov4" title="2">{
                return nil, args.Error(1)
        }</span>

        <span class="cov8" title="5">return args.Get(0).(*models.Post), args.Error(1)</span>
}

// Delete simula eliminar un post
func (m *MockPostRepository) Delete(id int) error <span class="cov1" title="1">{
        args := m.Called(id)
        return args.Error(0)
}</span>

// CreateComment simula crear un comentario
func (m *MockPostRepository) CreateComment(comment *models.Comment) error <span class="cov0" title="0">{
        args := m.Called(comment)
        return args.Error(0)
}</span>

// FindCommentsByPostID simula obtener comentarios de un post
func (m *MockPostRepository) FindCommentsByPostID(postID int) ([]*models.Comment, error) <span class="cov0" title="0">{
        args := m.Called(postID)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).([]*models.Comment), args.Error(1)</span>
}

// DeleteComment simula eliminar un comentario
func (m *MockPostRepository) DeleteComment(postID int, commentID int, userID int) error <span class="cov4" title="2">{
        args := m.Called(postID, commentID, userID)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package mocks

import (
        "tp06-testing/internal/models"

        "github.com/stretchr/testify/mock"
)

// MockUserRepository es un mock del UserRepository
type MockUserRepository struct {
        mock.Mock
}

// Create simula la creación de un usuario
func (m *MockUserRepository) Create(user *models.User) error <span class="cov1" title="1">{
        args := m.Called(user)
        return args.Error(0)
}</span>

// FindByEmail simula la búsqueda por email
func (m *MockUserRepository) FindByEmail(email string) (*models.User, error) <span class="cov9" title="5">{
        args := m.Called(email)

        // Si se configuró para devolver nil (usuario no encontrado)
        if args.Get(0) == nil </span><span class="cov4" title="2">{
                return nil, args.Error(1)
        }</span>

        <span class="cov6" title="3">return args.Get(0).(*models.User), args.Error(1)</span>
}

// FindByID simula la búsqueda por ID
func (m *MockUserRepository) FindByID(id int) (*models.User, error) <span class="cov10" title="6">{
        args := m.Called(id)

        if args.Get(0) == nil </span><span class="cov4" title="2">{
                return nil, args.Error(1)
        }</span>

        <span class="cov7" title="4">return args.Get(0).(*models.User), args.Error(1)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
